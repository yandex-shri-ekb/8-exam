JavaScript Styleguide
=====================

Именование
----------

- Конструкторы - UpperCamelCase
- Публичные методы/функции - lowerCamelCase
- Приватные/Защищенные методы/функции - _lowerCamelCase
- Переменные - lowerCamelCase
- Константы - UPPER_CASE

### Принципы именования

Имена идентификаторов по возможности сокращаются, но не в ущерб читабельности.

```javascript
var val,
    btn,
    idx,
    elem,
    prop,
    params;
```

**Имя класса** должно отражать сущность, например, `User`, `Map`. Исключение — базовые классы, задающие поведение. Например, `Observable`.

**Имя метода** должно отражать действие, например, `getParent()`, `startAction(action)`, `setState(newState)`.

**Имя поля** должно отражать сущность, например, `name`, `id`.

**Имя обработчика события** должно отражать действие, произошедшее в событии.
Если обработчик вызывается на действие, которое уже окончено к моменту его вызова, то имя обработчика
должно быть в прошедшем времени, например, `onButtonClicked`, `onGeoObjectLoaded`.
Если же событие является только инициатором каких-то действий, обработчик именуется в настоящем времени, например, `onChangePage`.

**Имя логической переменной** должно отражать вопрос, на который переменная отвечает.
Например, `isString`, `canWrite`.


Пробелы и переводы строк
------------------------

### Индентация

Для индентации используется 4 пробела.
Знаки табуляции не применяются.

### Запятая в качестве разделителя

После запятой всегда ставится пробел, кроме случаев, когда запятая находится в конце строки.
Перед запятой пробел не ставится.

```javascript
this.method(arg1, arg2, arg3);

this.method2(
    argWithARatherLongName,
    anotherLongNameArg,
    stillAnotherLongNameArg);
```

### Унарные операторы

[Унарные операторы](http://mzl.la/19kCJJU) не отбиваются пробелом от операнда.

```javascript
++i;
i--;
!false;
[1,2,3].indexOf(1) != -1;
~[1,2,3].indexOf(1);
1 / +0;
```

### Бинарные операторы

Все [бинарные операторы](http://mzl.la/19kCJJU) кроме запятой отбиваются пробелами с обеих сторон.
Запятая отбивается пробелом только справа.

```javascript
var i = a + (b * c),
    j = 10;

while(i += b, j--) {
    console.log(i);
}
```

### Тернарный оператор

Тернарный оператор может быть записан как в одну строку, так и в несколько.
В первом случае составные части оператора `?` и `:` отбиваются пробелами с обеих сторон.
Во втором случае переносятся на новую строку и отбиваются пробелом с правой стороны.

```javascript
isNAN ? 0 : 1;

longlonglonglonglonglonglonglongCondition
    ? operator1
    : operator2;

anotherlonglonglonglonglonglongCondition
    ? function() {
        console.log(true);
    }
    : function() {
        console.log(false);
    };
```

### Ключевые слова

Пробел ставится после ключевых слов **do** и **else**.
Пробел не ставится после ключевых слов **if**, **for**, **while**, **switch**.

Ключевое слово **else** не переносится на новую строку.

```javascript
if(true) {
    console.log('True is still positive');
} else {
    console.log('Something is definitely wrong');
}
```

После ключевого слова **break** ставится пустая строка за исключением последнего **break**.

```javascript
switch(value) {
    case 1:
        // actions if '1'
        break;

    case 2:
        // actions if '2'
        break;

    default:
        // else
        break;
}
```

### Функции

Пробел не ставится перед открывающей круглой скобкой.

```javascript
function() {};

function fn() {};
```

### Чейнинг

При chain-вызовах каждый следующий вызов метода переносится на новую строку.
Уровень индентации перенесенных методов увеличивается на 1.

Для первого вызова перенос не обязателен в случае, если это вызов метода объекта:

```javascript
obj.method()
    .then(function() {
    })
    .otherMethod();
```

При этом, если цепочка сразу начинается с вызова функции, перенос нужен:

```javascript
func()
    .method()
    .then(function() {
    })
    .otherMethod();
```

### Массивы

Открывающая и закрывающая квадратная скобка не отбивается пробелом от содержимого.
При этом перенос на новую строку допустим.

```javascript
var arr1 = [one, two, three];
    arr2 = [
        one,
        two,
        three
    ];
```

### Объекты

Открывающая и закрывающая фигурная скобка не отбивается пробелом от содержимого.
Двоеточие отбивается пробелом только с правой стороны.

```javascript
var obj1 = {one: 1, two: 2, three: 3};
    obj2 = {
        one: 1,
        two: 2,
        three: 3
    },
    obj3 = {one: 1, two: 2, three: {four: 4, five: 5}};
```

### Группировочные круглые скобки

В выражениях открывающая и закрывающая круглая скобка не отбивается пробелом от содержимого.

```javascript
var payment = basePayment + (credit - (elapsedYears * basePayment)) * rate;
```

### Блоки

Фигурные скобки в [блоках](http://mzl.la/GLYJr9) оформляются в «египетской нотации».
Открывающая фигурная скобка отбивается пробелом с левой стороны.
После открывающей фигурной скобки всегда делается перевод строки.

```javascript
if(true) {
    console.log('True is still positive');
} else {
    console.log('Something is definitely wrong');
}
```

```javascript
function canDrinkAlcohol(user) {
    return user.age >= 18;
}
```

### Переносы

Максимальная длина строки 120 символов, если строка выходит длиннее, то делаются переносы, с соответствующими отступами после переноса.

Закрывающие скобки прижимаются к переносимому коду:

```javascript
var processManager = MP.ProcessManager.createFromSource(
    MP.ProcessManagerAdapter.create('source-type-' + this.generateProcessSourceName()));
```

Операторы размещаются на новой строке:

```javascript
var debt = this.calculateBaseDebt() + this.calculateSharedDebt() + this.calculateDebtPayments()
    + this.calculateDebtFine();
```

### Многоуровневый код

Каждый новый уровень вложенности кода выделяется дополнительной индентацией:

```javascript
while(somethingBothersYou) {
    if(itIsYourFault) {
        workOnTheProblem();
    } else {
        tryToRelax();
    }
    keepBeeingHappy();
}
```

### Объявление переменных

При объявлении нескольких переменных используются отступы:

```javascript
var a = 1,
    b = 2,
    c = {
        prop: 1,
        prop: 2
    };
```

### Прочее

Пустые строки (blank lines) могут использоваться для группировки строк кода по смыслу.
Две и более пустые строки подряд недопустимы.

```javascript
createBot : function() {
    var env = new Env();
    env.name = 'Earth';
    env.year = 1984;
    env.city = 'Los Angeles';

    var bot = new Bot();
    bot.model = 'T-800';
    bot.assembler = 'Skynet';
    bot.target = 'John Connor';
    bot.setEnv(env);

    return bot;
}
```

Пробелы в конце строки всегда удаляются.
В конец файла всегда добавляется перевод строки.


Контроль выполнения
-------------------

### if

Для проверки условий всегда используется `if`:

```javascript
if(condition) {
    action();
}
```

Для проверки значения переменной на `null` и `undefined` допустимо пользоваться
операторами `&&` и `||` вместо `if`. Выражение в правой части этих операторов
должно быть простым (не содержать других условий, циклов и т.п):

```javascript
var x = y || {};

callback && callback();
```

Также допустимо использование тернарного оператора:

```javascript
condition ? action1() : action2();
```

### for

Мы стараемся не использовать ключевое слово for.
Для операций перебора существует стандартный метод `forEach`.

```javascript
[1, 2, 3].forEach(function(value) {
    console.log(value);
});
```

### for in

Конструкция **for…in** не используется.
Вместо нее перебор ключами осуществляется с помощью `Object.keys`.

```javascript
Object.keys(obj).forEach(function(key) {
    console.log(key);
});
```

### События

Имена событий пишутся в нижнем регистре, разделяются с помощью `-`.

```javascript
button.on('change-state', function(e) {
    alert('Button state is changed');
});
```

### Объявление переменных

К тому моменту когда переменная используется она уже должна быть объявлена.
Это правило не распространяется на функции.
Для улучшения читабельности кода, функции можно объявлять ниже.

```javascript
var hello = appendExclamation('world');

hello = hello.toUpperCase();

function appendExclamation(str) {
    return str + '!';
}
```

### Аргументы функции

У функции может быть максимум четыре аргумента.

### Вложенность

Максимальный уровень вложенности – 4.


Документирование
----------------

Для документирования кода используется [JSDoc](http://usejsdoc.org).

В JSDoc мы не описываем внутреннее устройство блоков, а пишем справочную информацию. Она должна писаться так, чтобы у
читающего полностью сложилось представление о том, как этим блоком пользоваться, что от него можно ожидать и какие есть
подводные камни без необходимости заглядывать в код.

## Текст описания

Документация пишется на русском языке.
Описание отделяется от тегов пустой строкой. Предложения пишутся с большой буквы,
в конце предложений всегда ставится точка:

```javascript
/**
 * Это стол, за ним едят.
 *
 * @private
 * @param {Chair} chair Это стул, на нем сидят.
 */
```

Текст может разбиваться на несколько строк или абзацев. Абзацы разделяются пустой строкой:

```javascript
/**
 * Пример длинного длинного длинного длинного
 * длинного абзаца.
 *
 * А это второй абзац.
 */
```

Допустимо использовать `markdown`:

```javascript
/**
 * Пример кода:
 *
 * ```javascript
 * block.someMethod(params)
 * ```
 *
 * @private
 */
```

Описание методов пишется в изъявительном наклонении.

Правильно:

```javascript
/**
 * Устанавливает модификатор.
 */
```

Не правильно:

```javascript
/**
 * Установить модификатор.
 */
```


### БЭМ-сущности

При использовании конструкции `BEM.DOM.decl()` со статическими свойствами, сниппет `JSDoc`
не содержит БЭМ-ориентированных тегов - имена БЭМ-сущностей будут выведены из контекста.

JS-параметры блоков описываются как аргументы коструктора. Каждый параметр представлен
свойством аргумента `params`:

```javascript
/**
 * Управляющий элемент интерфейса для удобного и наглядного выбора диапазона значений.
 *
 * @param {Object} params Параметры блока.
 * @param {Number} [params.min] Минимальное значение слайдера. Если не задано, будет использовано крайнее
 * правое значение шкалы.
 * @param {Number} [params.max] Максимальное значение слайдера. Если не задано, будет использовано крайнее
 * левое значение шкалы.
 */
BEM.DOM.decl('slider', {
    //...
});
```

В остальных случаях для обозначения БЭМ-сущности можно применять теги:

- `@block <имя блока>`
- `@mod <имя модификатора>`
- `@val <значение модификатора>`

### БЭМ-сущности на нескольких уровнях переопределения.

Если блок или модификатор описан на нескольких уровнях переопределения, основное описание
размещается на уровне `common`. На других уровнях размещается только дополнение к `common`,
специфичное для каждого уровня.

### Ссылки на другие БЭМ-сущности

Если в тексте документации необходимо сослаться на модификатор блока, применяется запись вида `_mod_val`:

```javascript
/**
 * Если установлен модификатор _some-mod_val, делает что-то.
 */
doSomething: function() {
    //...
}
```


### Свойства и методы

Внутри кода БЭМ-сущности должны быть документированы все публичные и защищенные свойства.

Все JSDoc-комментарии должны содержать тег про «видимость» описываемого свойства:
- публичное: `@public`
- приватное: `@private`
- защищенное: `@protected`

Свойства `onSetMod` и `onElemSetMod` всегда помечаются тегом `@private`.

JSDoc для публичного метода должен содержать краткое описание, перечисление всех аргументов, возвращаемое значение.
Возвращаемое значение описывается в конце сниппета:

```javascript
/**
 * Подписка на событие.
 *
 * @public
 * @param {String|String[]} eventType
 * @param {Object} [eventData]
 * @param {Function} handler
 * @returns {Object} Возвращает контекст, в котором был вызван
 */
bind: function(eventType, eventData, handler) {
    // ...
}
```

Для защищенного метода в описании дополнительно указывается, в каких случаях метод нужно переопределять и когда
он вызывается.

Устаревшие свойства помечаются тегом `@deprecated`, после которого указывается:
- версия, в которой свойство было объявлено устаревшим
- рекомендуемая замена

Пример:

```javascript
/**
 * Пример документирования устаревших методов.
 *
 * @deprecated В версиях >=1.1 рекомендуется использовать coolerExample.
 */
example: function() {
    //...
}
```

Если метод не предназначен для переопределения, его помечают тегом `@final`.

```javascript
/**
 * Показывает блок.
 *
 * @public
 * @final
 */
show: function() {
    //...
}
```

### Параметры методов

Для параметров обязательно указание типов. Описание параметра начинается с большой буквы, в конце ставится точка.
Тип не отделяется от описания дефисом.

Правильно:

```javascript
/**
 * @param {Number} x Параметр.
 */
```

Не правильно:

```javascript
/**
 * @param x - параметр
 */
```

### Порядок оформления сниппетов

1. Блок описания. Отделяется от тегов пустой строкой.
2. "Видимость": тег `@public`, `@private` и `@protected`.
3. Тег `@deprecated`, если нужен.
4. Тег `@final`, если нужен.
5. Описание параметров (теги `@param`).
6. Возвращаемое значение (тег `@returns`).

```javascript
/**
 * Показывает блок.
 *
 * @public
 * @deprecated Начиная с 2.0, используйте метод present.
 * @final
 * @param {Object} coords Координаты.
 * @param {Number} coords.x Координата X.
 * @param {Number} coords.y Координата Y.
 * @returns {BEM.DOM} Возвращает экземпляр блока.
 */
show: function(coords) {
    //...
}
```

### События

Все события описываются при помощи тега `@event` в начале тела блока.
Для события указываются типы и описания всех дополнительных данных:

```javascript
/**
 * Блок.
 */
BEM.DOM.decl('block', {
    /**
     * Событие.
     *
     * @event block#event
     * @param {string} data Дополнительные данные.
     */
});


```

В теге `@event` указывается полный идентификатор БЭМ-сущности. Для модификаторов:

```javascript
/**
 * Генерируется, когда оба ползунка устанавливаются в одно значение.
 *
 * @event slider_type_range#collapse
 */
```


Прочее
------

### Блоки кода

Блоки кода всегда обрамляются фигурными скобками, даже если содержат всего одну инструкцию:

```javascript
if(condintion) {
    something();
}

while(condinition) {
    something();
}

for(;;) {
    something();
}

do {
    something();
} while(condition);
```

### Кавычки

Строки записываются с использованием одинарных кавычек.

```javascript
var lyrics = 'Never gonna give you up, Never gonna let you down';
```

Поля в объектах не обрамляются кавычками, если это возможно.

```javascript
{
    display: 'block',
    border: '1px solid #ccc',
    'box-sizing': 'border-box'
}
```

### with

Мы не используем **with**.

### arguments.caller и arguments.callee

Мы не используем `arguments.caller` и `arguments.callee`.

### Строгое сравнение

При любой неоднозначности используем операторы строгого сравнения `===` и `!==`.

### IIF

Оборачиваем круглыми скобками.

```javascript
(function() {
    ...
})()
```

### Точка с запятой

Ставится всегда. Исключение – последнее выражение в однострочном блоке.

```javascript
var name = (function() { return 'Anton' })();
```
